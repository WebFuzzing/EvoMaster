package org.evomaster.core.sql

import org.evomaster.client.java.controller.api.dto.database.operations.*
import org.evomaster.client.java.sql.DbInfoExtractor
import org.evomaster.client.java.sql.SqlScriptRunner
import org.evomaster.core.search.gene.*
import org.evomaster.core.search.gene.collection.EnumGene
import org.evomaster.core.search.gene.datetime.DateTimeGene
import org.evomaster.core.search.gene.datetime.FormatForDatesAndTimes
import org.evomaster.core.search.gene.numeric.DoubleGene
import org.evomaster.core.search.gene.numeric.IntegerGene
import org.evomaster.core.search.gene.numeric.LongGene
import org.evomaster.core.search.gene.placeholder.ImmutableDataHolderGene
import org.evomaster.core.search.gene.sql.SqlAutoIncrementGene
import org.evomaster.core.search.gene.sql.SqlPrimaryKeyGene
import org.evomaster.core.search.gene.string.StringGene
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertAll
import java.sql.Connection
import java.sql.DriverManager

class SqlInsertBuilderTest {


    companion object {

        private lateinit var connection: Connection

        const val H2_MAX_VARCHAR_LENGTH = 1000000000

        @BeforeAll
        @JvmStatic
        fun initClass() {
            connection = DriverManager.getConnection("jdbc:h2:mem:db_test", "sa", "")
        }
    }

    @BeforeEach
    fun initTest() {

        //custom H2 command
        SqlScriptRunner.execCommand(connection, "DROP ALL OBJECTS;")
    }


    @Test
    fun testSimpleInt() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x INT not null);")

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeTopGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is IntegerGene)
    }


    @Test
    fun testColumnSelection() {

        SqlScriptRunner.execCommand(connection, """
                    CREATE TABLE Foo(
                        id bigint generated by default as identity primary key,
                        x INT,
                        y INT not null,
                        z INT
                    );
                """)

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeTopGenes()

        assertTrue(genes.any { it.name.equals("x", ignoreCase = true) })
        assertTrue(genes.any { it.name.equals("y", ignoreCase = true) })

        /*
            - id should had been skipped because auto-incremented value.
              however, being a primary key, we still need it for the tests
              in a non-modifiable, non-printable Gene.
            - z skipped because nullable and not requested
         */
        assertTrue(genes.any { it.name.equals("id", ignoreCase = true) })
        assertFalse(genes.any { it.name.equals("z", ignoreCase = true) })

        assertEquals(3, genes.size)
        assertEquals(1, genes.filterIsInstance(IntegerGene::class.java).size)
        assertEquals(1, genes.filterIsInstance(SqlPrimaryKeyGene::class.java).size)
    }


    @Test
    fun testVarchar() {

        SqlScriptRunner.execCommand(connection, """
                    CREATE TABLE Foo(
                        x varchar(255)  not null,
                        y VARCHAR(128)  not null,
                        z varchar  not null
                    );
                """)

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X", "Y", "Z"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeTopGenes()

        assertEquals(3, genes.size)
        assertTrue(genes[0] is StringGene)
        assertTrue(genes[1] is StringGene)
        assertTrue(genes[2] is StringGene)

        val x = genes.find { it.name.equals("X", ignoreCase = true) } as StringGene
        assertEquals(0, x.minLength)
        assertEquals(255, x.maxLength)

        val y = genes.find { it.name.equals("Y", ignoreCase = true) } as StringGene
        assertEquals(0, y.minLength)
        assertEquals(128, y.maxLength)

        val z = genes.find { it.name.equals("Z", ignoreCase = true) } as StringGene
        assertEquals(0, z.minLength)
        /**
         * http://www.h2database.com/html/datatypes.html?highlight=constraint&search=constraint#character_varying_type
         * The allowed length is from 1 to 1,000,000,000 characters. The length is a size constraint; only
         * the actual data is persisted. Length, if any, should be specified in characters
         */
        assertEquals(H2_MAX_VARCHAR_LENGTH, z.maxLength)
    }


    @Test
    fun testForeignKey() {
        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE Foo(
                id bigint generated by default as identity,
                barId bigint not null,
                primary key (id)
            );
            CREATE TABLE Bar(
                id bigint generated by default as identity,
                primary key (id)
            );
            ALTER TABLE Foo add constraint barIdKey foreign key (barId) references Bar;
        """)

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        //Bar is independent
        val barActions = builder.createSqlInsertionAction("BAR", setOf())
        assertEquals(1, barActions.size)

        //Foo has a FK to Bar
        val fooActions = builder.createSqlInsertionAction("FOO", setOf())
        assertEquals(2, fooActions.size)
    }


    @Test
    fun testTimeStamp() {

        SqlScriptRunner.execCommand(connection, """
            create table Foo (
                time timestamp not null
            )
        """)

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("TIME"))
        assertEquals(1, actions.size)

        val genes = actions[0].seeTopGenes()
        assertEquals(1, genes.size)
        assertTrue(genes[0] is DateTimeGene)

        val dateTimeGene = genes[0] as DateTimeGene
        assertEquals(FormatForDatesAndTimes.DATETIME, dateTimeGene.format)
        assertTrue(dateTimeGene.date.onlyValidDates)
        assertTrue(dateTimeGene.time.onlyValidHours)
    }

    @Test
    fun testRealColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x REAL not null);")

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeTopGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is DoubleGene)
    }


    @Test
    fun testCLOBColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x CLOB not null);")

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeTopGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is StringGene)
    }

    @Test
    fun testSmallIntColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x SMALLINT not null);")

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeTopGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is IntegerGene)
    }

    @Test
    fun testTinyIntColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x TINYINT not null);")

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeTopGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is IntegerGene)
    }



    @Test
    fun testTimeStampColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x TIMESTAMP not null);")

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeTopGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is DateTimeGene)

        val dateTimeGene = genes[0] as DateTimeGene
        assertEquals(FormatForDatesAndTimes.DATETIME, dateTimeGene.format)
        assertTrue(dateTimeGene.date.onlyValidDates)
        assertTrue(dateTimeGene.time.onlyValidHours)
    }

    @Test
    fun testBooleanColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x BOOLEAN not null);")

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeTopGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is BooleanGene)
    }

    @Test
    fun testCharColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x CHAR not null);")

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeTopGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is StringGene)
    }


    @Test
    fun testBigIntColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x BIGINT not null);")

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeTopGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is LongGene)
    }

    @Test
    fun testDoubleColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x DOUBLE not null);")

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeTopGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is DoubleGene)
    }

    @Test
    fun testTableCalledUsers() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Users(id  bigserial not null, primary key (id));")

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("USERS", setOf("ID"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeTopGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is SqlPrimaryKeyGene)
        assertTrue((genes[0] as SqlPrimaryKeyGene).gene is SqlAutoIncrementGene)
    }


    private class DirectDatabaseExecutor : DatabaseExecutor {

        override fun executeDatabaseInsertionsAndGetIdMapping(dto: DatabaseCommandDto): InsertionResultsDto? {
            return null
        }

        override fun executeMongoDatabaseInsertions(dto: MongoDatabaseCommandDto): MongoInsertionResultsDto? {
            return null
        }

        override fun executeDatabaseCommandAndGetQueryResults(dto: DatabaseCommandDto): QueryResultDto? {
            return SqlScriptRunner.execCommand(connection, dto.command).toDto()
        }

        override fun executeDatabaseCommand(dto: DatabaseCommandDto): Boolean {
            return false
        }
    }


    @Test
    fun testExtractExistingPKsEmpty() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Users(id  bigserial not null, primary key (id));")

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.extractExistingPKs()
        assertEquals(0, actions.size)
    }


    @Test
    fun testExtractExistingPKsOneTable() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Users(id  bigserial not null, primary key (id));")
        SqlScriptRunner.execCommand(connection, "INSERT INTO Users (id) VALUES (0)")
        SqlScriptRunner.execCommand(connection, "INSERT INTO Users (id) VALUES (1)")
        SqlScriptRunner.execCommand(connection, "INSERT INTO Users (id) VALUES (2)")

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.extractExistingPKs()

        assertAll(
                { assertEquals(3, actions.size) },
                { actions.all { it.representExistingData } },
                { actions.all { it.seeTopGenes().size == 1 } },
                { actions.all { it.seeTopGenes()[0] is SqlPrimaryKeyGene } },
                { actions.all { (it.seeTopGenes()[0] as SqlPrimaryKeyGene).gene is ImmutableDataHolderGene } }
        )
    }


    @Test
    fun testExtractExistingPKsMultiTables() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE X (id  bigserial not null, primary key (id));
            CREATE TABLE Y (foo varchar(256), bar int, primary key(foo));
            INSERT INTO X (id) VALUES (0);
            INSERT INTO X (id) VALUES (1);
            INSERT INTO X (id) VALUES (2);
            INSERT INTO Y (foo,bar) VALUES ('a',5);
            INSERT INTO Y (foo,bar) VALUES ('b',6);
        """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.extractExistingPKs()

        assertAll(
                { assertEquals(5, actions.size) },
                { actions.all { it.representExistingData } },
                { assertEquals(2, actions.map { it.table.name }.distinct().count()) },
                { actions.all { it.seeTopGenes().size == 1 } },
                { actions.all { it.seeTopGenes()[0] is SqlPrimaryKeyGene } },
                { actions.all { (it.seeTopGenes()[0] as SqlPrimaryKeyGene).gene is ImmutableDataHolderGene } }
        )
    }

    @Test
    fun testStringEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status varchar(1) not null);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in ('A', 'B'));
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf("A", "B"), enumGene.values.toSet())

    }

    @Test
    fun testIntegerEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status INT not null);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (42, 77));
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf(42, 77), enumGene.values.toSet())

    }


    @Test
    fun testBooleanEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status BOOLEAN not null);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (true, false));
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf(true, false), enumGene.values.toSet())

    }

    @Test
    fun testTinyIntEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status TINYINT not null);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (42, 77));
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf(42, 77), enumGene.values.toSet())

    }

    @Test
    fun testSmallIntEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status SMALLINT not null);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (42, 77));
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf(42, 77), enumGene.values.toSet())

    }

    @Test
    fun testCharEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status CHAR not null);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in ('A', 'B'));
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf("A", "B"), enumGene.values.toSet())

    }

    @Test
    fun testBigIntEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status BIGINT not null);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (42, 77));
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf(42L, 77L), enumGene.values.toSet())

    }

    @Test
    fun testDoubleEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status DOUBLE not null);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (1.0, 2.5));
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf(1.0, 2.5), enumGene.values.toSet())

    }

    @Test
    fun testRealEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status REAL not null);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (1.0, 2.5));
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf(1.0, 2.5), enumGene.values.toSet())

    }

    @Test
    fun testDecimalEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status DECIMAL not null);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (1.0, 2.5));
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf(1.0f, 2.5f), enumGene.values.toSet())

    }

    @Test
    fun testClobEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status CLOB not null);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in ('A', 'B'));
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf("A", "B"), enumGene.values.toSet())

    }

    @Test
    fun testBlobEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status BLOB not null);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (x'0000', x'FFFF'));
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf("X'0000'", "X'ffff'"), enumGene.values.toSet())

    }

    @Test
    fun testMultipleLowerBounds() {
        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE Foo(x INT not null);
            
            ALTER TABLE Foo add constraint lowerBound1 check (x >= -10);

            ALTER TABLE Foo add constraint lowerBound2 check (x >= -100);

            ALTER TABLE Foo add constraint lowerBound3 check (x >= -1000);
        """)

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val fooActions = builder.createSqlInsertionAction("FOO", setOf())

        assertEquals(1, fooActions.size)
        assertEquals(1, fooActions[0].seeTopGenes().size)

        val gene = fooActions[0].seeTopGenes()[0] as IntegerGene
        assertEquals(-10, gene.min)

    }

    @Test
    fun testMultipleUpperBounds() {
        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE Foo(x INT not null);
            
            ALTER TABLE Foo add constraint upperBound1 check (x <= 10);

            ALTER TABLE Foo add constraint upperBound2 check (x <= 100);

            ALTER TABLE Foo add constraint upperBound3 check (x <= 1000);
        """)

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val fooActions = builder.createSqlInsertionAction("FOO", setOf())

        assertEquals(1, fooActions.size)
        assertEquals(1, fooActions[0].seeTopGenes().size)

        val gene = fooActions[0].seeTopGenes()[0] as IntegerGene
        assertEquals(10, gene.max)

    }

    @Test
    fun testMultipleUpperAndLowerBounds() {
        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE Foo(x INT not null);
            
            
            ALTER TABLE Foo add constraint lowerBound1 check (x >= -10);

            ALTER TABLE Foo add constraint lowerBound2 check (x >= -100);

            ALTER TABLE Foo add constraint lowerBound3 check (x >= -1000);
            
            ALTER TABLE Foo add constraint upperBound1 check (x <= 10);

            ALTER TABLE Foo add constraint upperBound2 check (x <= 100);

            ALTER TABLE Foo add constraint upperBound3 check (x <= 1000);
        """)

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val fooActions = builder.createSqlInsertionAction("FOO", setOf())

        assertEquals(1, fooActions.size)
        assertEquals(1, fooActions[0].seeTopGenes().size)

        val gene = fooActions[0].seeTopGenes()[0] as IntegerGene
        assertEquals(-10, gene.min)
        assertEquals(10, gene.max)

    }

    @Test
    fun testMultipleRangeConstraintAndLowerAndUpperBounds() {
        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE Foo(x INT not null);
            
            ALTER TABLE Foo add constraint rangeConstraint check (x = 10);

            ALTER TABLE Foo add constraint lowerBound check (x >= 0);

            ALTER TABLE Foo add constraint upperBound check (x <= 1000);
            
        """)

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val fooActions = builder.createSqlInsertionAction("FOO", setOf())

        assertEquals(1, fooActions.size)
        assertEquals(1, fooActions[0].seeTopGenes().size)

        val gene = fooActions[0].seeTopGenes()[0] as IntegerGene
        assertEquals(10, gene.min)
        assertEquals(10, gene.max)

    }


    @Test
    fun testIntersectEnumConstraints() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status CHAR not null);

            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS1 CHECK (status in ('A', 'B'));

            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS2 CHECK (status in ('B', 'C'));

            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS3 CHECK (status in ('D', 'B'));

            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS4 CHECK (status in ('X', 'B'));
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf("B"), enumGene.values.toSet())

    }


    @Test
    fun testNoIntersectionEnumConstraints() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status CHAR not null);

            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS1 CHECK (status in ('A', 'B', 'C'));

            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS2 CHECK (status in ('D', 'E', 'F'));
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        try {
            builder.createSqlInsertionAction("FOO", setOf("status"))
            fail<Any>()
        } catch (ex: RuntimeException) {
            // do nothing
        }
    }

    @Test
    fun testSingleLikeConstraint() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (f_id TEXT NOT NULL);

            ALTER TABLE FOO ADD CONSTRAINT check_f_id CHECK (f_id LIKE 'hi');
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("f_id"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf("hi"), enumGene.values.toSet())

    }

    @Test
    fun testManyLikeConstraints() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (f_id TEXT NOT NULL);

            ALTER TABLE FOO ADD CONSTRAINT check_f_id_1 CHECK (f_id LIKE 'hi');

            ALTER TABLE FOO ADD CONSTRAINT check_f_id_2 CHECK (f_id LIKE 'low');
            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        try {
            builder.createSqlInsertionAction("FOO", setOf("f_id"))
            fail<Any>()
        } catch (ex: IllegalArgumentException) {
            // do nothing
        }
    }

    @Test
    fun testManyOrLikeConstantConstraint() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (f_id TEXT NOT NULL);

            ALTER TABLE FOO ADD CONSTRAINT check_f_id_1 CHECK (f_id LIKE 'hi' OR f_id LIKE 'low');

            """)

        val schema = DbInfoExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("f_id"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeTopGenes().size)
        assertTrue(actions[0].seeTopGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeTopGenes()[0] as EnumGene<*>

        assertEquals(setOf("hi", "low"), enumGene.values.toSet())

    }

    @Test
    fun testSingleInsertionForTable() {
        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE ROOTA(
                id INT not null,
                name TEXT not null,
                primary key (id)
            );
            CREATE TABLE NODEB(
                id INT not null,
                name TEXT not null,
                rootAId INT not null,
                primary key (id)
            );
            CREATE TABLE NODEC(
                id INT not null,
                name TEXT not null,
                rootAId INT not null,
                primary key (id)
            );
            CREATE TABLE LEAFD(
                id INT not null,
                name TEXT not null,
                nodeBId INT not null,
                nodeCId INT not null,
                primary key (id)
            );
            ALTER TABLE NODEB add constraint bToA foreign key (rootAId) references ROOTA;
            ALTER TABLE NODEC add constraint cToA foreign key (rootAId) references ROOTA;
            ALTER TABLE LEAFD add constraint dToB foreign key (nodeBId) references NODEB;
            ALTER TABLE LEAFD add constraint dToC foreign key (nodeCId) references NODEC;
        """)

        val dto = DbInfoExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val disabled = builder.createSqlInsertionAction("LEAFD", setOf(), enableSingleInsertionForTable = false)
        // ABACD
        assertEquals(5, disabled.size)

        val enabled = builder.createSqlInsertionAction("LEAFD", setOf(), enableSingleInsertionForTable = true)

        // ABCD or ACBD
        assertEquals(4, enabled.size)
        assertEquals("ROOTA", enabled[0].table.name)
        assertEquals("LEAFD", enabled[3].table.name)
        assertTrue(enabled.subList(1,3).map { it.table.name }.containsAll(listOf("NODEB", "NODEC")))
    }

    ////// Tests Numeric parsing for Min/Max Bounds

    /**
     * When having a check constraint that contains only lower bound,
     * then the SqlInsertBuilder takes it as the min value
     */
    @Test
    fun minInt() {

        val schemaQuery = """
            CREATE TABLE products(price int not null);
            ALTER TABLE products add CHECK (price>100);
        """.trimIndent()

        val newActions = getSqlActionsFromSchema(schemaQuery)

        assertEquals(1, newActions.size)
        val genes = newActions[0].seeTopGenes()
        assertEquals(1, genes.size)

        assertTrue(genes[0] is IntegerGene)
        assertEquals(101, (genes[0] as IntegerGene).min)
        assertEquals(2147483647, (genes[0] as IntegerGene).max)
    }

    /**
     * When having a check constraint that contains only upper bound,
     * then the SqlInsertBuilder takes it as the max value
     */
    @Test
    fun maxInt() {

        val schemaQuery = """
            CREATE TABLE products(price int not null);
            ALTER TABLE products add CHECK (price<9999);
        """.trimIndent()

        val newActions = getSqlActionsFromSchema(schemaQuery)

        assertEquals(1, newActions.size)
        val genes = newActions[0].seeTopGenes()
        assertEquals(1, genes.size)

        assertTrue(genes[0] is IntegerGene)
        assertEquals(-2147483648, (genes[0] as IntegerGene).min)
        assertEquals(9998, (genes[0] as IntegerGene).max)
    }

    /**
     * When having two separate check constraints that contain an upper and lower bound,
     * then the SqlInsertBuilder takes them as min/max
     */
    @Test
    fun minAndMaxIntSeparated() {

        val schemaQuery = """
            CREATE TABLE products(price int not null);
            ALTER TABLE products add CHECK (price>100);
            ALTER TABLE products add CHECK (price<9999);
        """.trimIndent()

        val newActions = getSqlActionsFromSchema(schemaQuery)

        assertEquals(1, newActions.size)
        val genes = newActions[0].seeTopGenes()
        assertEquals(1, genes.size)

        assertTrue(genes[0] is IntegerGene)
        assertEquals(101, (genes[0] as IntegerGene).min)
        assertEquals(9998, (genes[0] as IntegerGene).max)
    }

    /**
     * When having a check constraint that contains an upper and lower bound,
     * then the SqlInsertBuilder takes them as min/max
     */
    @Test
    fun minAndMaxIntInTheSameCheck() {

        val schemaQuery = """
            CREATE TABLE products(price int not null);
            ALTER TABLE products add CHECK (price>100 AND price<9999);
        """.trimIndent()

        val newActions = getSqlActionsFromSchema(schemaQuery)

        assertEquals(1, newActions.size)
        val genes = newActions[0].seeTopGenes()
        assertEquals(1, genes.size)

        assertTrue(genes[0] is IntegerGene)
        assertEquals(101, (genes[0] as IntegerGene).min)
        assertEquals(9998, (genes[0] as IntegerGene).max)
    }

    /**
     * When comparing two different fields in the same check condition,
     * then the parser in create insert SQL Builder Action fails
     */
    @Test
    fun compareTwoFields() {

        val schemaQuery = """
            CREATE TABLE products(price int not null, min_price int not null);
            ALTER TABLE products add CHECK (price > min_price);
        """.trimIndent()

        try {
            getSqlActionsFromSchema(schemaQuery)
        } catch (e: Exception) {
            // An exception is thrown when parsing the check with two fields
            return
        }
        fail<Any>("Expected an exception to be thrown")
    }

    /**
     * When a column is BigInt type, then the gene is a LongGene
     */
    @Test
    fun bigIntToLongGene() {

        val schemaQuery = """
            CREATE TABLE products(price bigint not null);
            ALTER TABLE products add CHECK (price>100 AND price<9999);
        """.trimIndent()

        val newActions = getSqlActionsFromSchema(schemaQuery)

        assertEquals(1, newActions.size)
        val genes = newActions[0].seeTopGenes()
        assertEquals(1, genes.size)

        assertTrue(genes[0] is LongGene)
        assertEquals(101, (genes[0] as LongGene).min)
        assertEquals(9998, (genes[0] as LongGene).max)
    }

    /**
     * When a column is Float type, then the gene is a DoubleGene
     */
    @Test
    fun floatToDouble() {

        val schemaQuery = """
            CREATE TABLE products(price float not null);
        """.trimIndent()

        val newActions = getSqlActionsFromSchema(schemaQuery)

        assertEquals(1, newActions.size)
        val genes = newActions[0].seeTopGenes()
        assertEquals(1, genes.size)

        assertTrue(genes[0] is DoubleGene)
    }

    /**
     * When setting lower and upper bounds in a Long Column,
     * Then they are considered as min/max in the gene
     */
    @Test
    fun setMinMaxInLongGene() {

        val schemaQuery = """
            CREATE TABLE products(price long not null);
            ALTER TABLE products add CHECK (price > 100);
            ALTER TABLE products add CHECK (price < 9999);
        """.trimIndent()

        val newActions = getSqlActionsFromSchema(schemaQuery)

        assertEquals(1, newActions.size)
        val genes = newActions[0].seeTopGenes()
        assertEquals(1, genes.size)

        assertTrue(genes[0] is LongGene)
        assertEquals(101, (genes[0] as LongGene).min)
        assertEquals(9998, (genes[0] as LongGene).max)
    }

    /**
     * When setting lower and upper bounds in a Double Column,
     * then the parser in create insert SQL Builder Action fails
     */
    @Test
    fun setMinMaxInDoubleGene() {

        val schemaQuery = """
            CREATE TABLE products(price double not null);
            ALTER TABLE products add CHECK (price > 100);
            ALTER TABLE products add CHECK (price < 9999);
        """.trimIndent()

        try {
            getSqlActionsFromSchema(schemaQuery)
        } catch (e: Exception) {
            // An exception is thrown when parsing the check with a lower or upper bound
            return
        }
        fail<Any>("Expected an exception to be thrown")
    }

    @Throws(Exception::class)
    private fun getSqlActionsFromSchema(schemaQuery: String): List<SqlAction> {
        SqlScriptRunner.execCommand(connection, schemaQuery)

        val schemaDto = DbInfoExtractor.extract(connection)
        val sqlInsertBuilder = SqlInsertBuilder(schemaDto, null)

        return sqlInsertBuilder.createSqlInsertionAction(
            schemaDto.tables[0].name,
            setOf("*"),
            mutableListOf(),
            false,
            false,
            false
        )
    }
}