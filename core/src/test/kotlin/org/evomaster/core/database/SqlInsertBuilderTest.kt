package org.evomaster.core.database

import org.evomaster.client.java.controller.api.dto.database.operations.DatabaseCommandDto
import org.evomaster.client.java.controller.api.dto.database.operations.QueryResultDto
import org.evomaster.client.java.controller.db.SqlScriptRunner
import org.evomaster.client.java.controller.internal.db.SchemaExtractor
import org.evomaster.core.search.gene.*
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertAll
import java.sql.Connection
import java.sql.DriverManager

class SqlInsertBuilderTest {


    companion object {

        private lateinit var connection: Connection

        @BeforeAll
        @JvmStatic
        fun initClass() {
            connection = DriverManager.getConnection("jdbc:h2:mem:db_test", "sa", "")
        }
    }

    @BeforeEach
    fun initTest() {

        //custom H2 command
        SqlScriptRunner.execCommand(connection, "DROP ALL OBJECTS;")
    }


    @Test
    fun testSimpleInt() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x INT);")

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is IntegerGene)
    }


    @Test
    fun testColumnSelection() {

        SqlScriptRunner.execCommand(connection, """
                    CREATE TABLE Foo(
                        id bigint generated by default as identity,
                        x INT,
                        y INT not null,
                        z INT
                    );
                """)

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeGenes()

        assertTrue(genes.any { it.name.equals("x", ignoreCase = true) })
        assertTrue(genes.any { it.name.equals("y", ignoreCase = true) })

        /*
            - id should had been skipped because auto-incremented value.
              however, being a primary key, we still need it for the tests
              in a non-modifiable, non-printable Gene.
            - z skipped because nullable and not requested
         */
        assertTrue(genes.any { it.name.equals("id", ignoreCase = true) })
        assertFalse(genes.any { it.name.equals("z", ignoreCase = true) })

        assertEquals(3, genes.size)
        assertEquals(2, genes.filterIsInstance(IntegerGene::class.java).size)
        assertEquals(1, genes.filterIsInstance(SqlPrimaryKeyGene::class.java).size)
    }


    @Test
    fun testVarchar() {

        SqlScriptRunner.execCommand(connection, """
                    CREATE TABLE Foo(
                        x varchar(255),
                        y VARCHAR(128),
                        z varchar
                    );
                """)

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X", "Y", "Z"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeGenes()

        assertEquals(3, genes.size)
        assertTrue(genes[0] is StringGene)
        assertTrue(genes[1] is StringGene)
        assertTrue(genes[2] is StringGene)

        val x = genes.find { it.name.equals("X", ignoreCase = true) } as StringGene
        assertEquals(0, x.minLength)
        assertEquals(255, x.maxLength)

        val y = genes.find { it.name.equals("Y", ignoreCase = true) } as StringGene
        assertEquals(0, y.minLength)
        assertEquals(128, y.maxLength)

        val z = genes.find { it.name.equals("Z", ignoreCase = true) } as StringGene
        assertEquals(0, z.minLength)
        assertEquals(Int.MAX_VALUE, z.maxLength)
    }


    @Test
    fun testForeignKey() {
        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE Foo(
                id bigint generated by default as identity,
                barId bigint not null,
                primary key (id)
            );
            CREATE TABLE Bar(
                id bigint generated by default as identity,
                primary key (id)
            );
            ALTER TABLE Foo add constraint barIdKey foreign key (barId) references Bar;
        """)

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        //Bar is independent
        val barActions = builder.createSqlInsertionAction("BAR", setOf())
        assertEquals(1, barActions.size)

        //Foo has a FK to Bar
        val fooActions = builder.createSqlInsertionAction("FOO", setOf())
        assertEquals(2, fooActions.size)
    }


    @Test
    fun testTimeStamp() {

        SqlScriptRunner.execCommand(connection, """
            create table Foo (
                time timestamp not null,
            )
        """)

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("TIME"))
        assertEquals(1, actions.size)

        val genes = actions[0].seeGenes()
        assertEquals(1, genes.size)
        assertTrue(genes[0] is SqlTimestampGene)
    }

    @Test
    fun testRealColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x REAL);")

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is DoubleGene)
    }


    @Test
    fun testCLOBColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x CLOB);")

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is StringGene)
    }

    @Test
    fun testSmallIntColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x SMALLINT);")

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is IntegerGene)
    }

    @Test
    fun testTinyIntColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x TINYINT);")

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is IntegerGene)
    }


    @Test
    fun testTimeStampColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x TIMESTAMP);")

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is SqlTimestampGene)
    }

    @Test
    fun testBooleanColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x BOOLEAN);")

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is BooleanGene)
    }

    @Test
    fun testCharColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x CHAR);")

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is StringGene)
    }


    @Test
    fun testBigIntColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x BIGINT);")

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is LongGene)
    }

    @Test
    fun testDoubleColumn() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Foo(x DOUBLE);")

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("FOO", setOf("X"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is DoubleGene)
    }

    @Test
    fun testTableCalledUsers() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Users(id  bigserial not null, primary key (id));")

        val dto = SchemaExtractor.extract(connection)

        val builder = SqlInsertBuilder(dto)

        val actions = builder.createSqlInsertionAction("USERS", setOf("ID"))

        assertEquals(1, actions.size)

        val genes = actions[0].seeGenes()

        assertEquals(1, genes.size)
        assertTrue(genes[0] is SqlPrimaryKeyGene)
        assertTrue((genes[0] as SqlPrimaryKeyGene).gene is SqlAutoIncrementGene)
    }


    private class DirectDatabaseExecutor : DatabaseExecutor {

        override fun executeDatabaseInsertionsAndGetIdMapping(dto: DatabaseCommandDto): Map<Long, Long>? {
            return null
        }

        override fun executeDatabaseCommandAndGetQueryResults(dto: DatabaseCommandDto): QueryResultDto? {
            return SqlScriptRunner.execCommand(connection, dto.command).toDto()
        }

        override fun executeDatabaseCommand(dto: DatabaseCommandDto): Boolean {
            return false
        }
    }


    @Test
    fun testExtractExistingPKsEmpty() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Users(id  bigserial not null, primary key (id));")

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.extractExistingPKs()
        assertEquals(0, actions.size)
    }


    @Test
    fun testExtractExistingPKsOneTable() {

        SqlScriptRunner.execCommand(connection, "CREATE TABLE Users(id  bigserial not null, primary key (id));")
        SqlScriptRunner.execCommand(connection, "INSERT INTO Users (id) VALUES (0)")
        SqlScriptRunner.execCommand(connection, "INSERT INTO Users (id) VALUES (1)")
        SqlScriptRunner.execCommand(connection, "INSERT INTO Users (id) VALUES (2)")

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.extractExistingPKs()

        assertAll(
                { assertEquals(3, actions.size) },
                { actions.all { it.representExistingData } },
                { actions.all { it.seeGenes().size == 1 } },
                { actions.all { it.seeGenes()[0] is SqlPrimaryKeyGene } },
                { actions.all { (it.seeGenes()[0] as SqlPrimaryKeyGene).gene is ImmutableDataHolderGene } }
        )
    }


    @Test
    fun testExtractExistingPKsMultiTables() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE X (id  bigserial not null, primary key (id));
            CREATE TABLE Y (foo varchar(256), bar int, primary key(foo));
            INSERT INTO X (id) VALUES (0);
            INSERT INTO X (id) VALUES (1);
            INSERT INTO X (id) VALUES (2);
            INSERT INTO Y (foo,bar) VALUES ('a',5);
            INSERT INTO Y (foo,bar) VALUES ('b',6);
        """)

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.extractExistingPKs()

        assertAll(
                { assertEquals(5, actions.size) },
                { actions.all { it.representExistingData } },
                { assertEquals(2, actions.map { it.table.name }.distinct().count()) },
                { actions.all { it.seeGenes().size == 1 } },
                { actions.all { it.seeGenes()[0] is SqlPrimaryKeyGene } },
                { actions.all { (it.seeGenes()[0] as SqlPrimaryKeyGene).gene is ImmutableDataHolderGene } }
        )
    }

    @Test
    fun testStringEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status varchar(1));
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in ('A', 'B'));
            """)

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeGenes().size)
        assertTrue(actions[0].seeGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeGenes()[0] as EnumGene<*>;

        assertEquals(setOf("A", "B"), enumGene.values.toSet());

    }

    @Test
    fun testIntegerEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status INT);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (42, 77));
            """)

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeGenes().size)
        assertTrue(actions[0].seeGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeGenes()[0] as EnumGene<*>;

        assertEquals(setOf(42, 77), enumGene.values.toSet());

    }


    @Test
    fun testBooleanEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status BOOLEAN);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (true, false));
            """)

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeGenes().size)
        assertTrue(actions[0].seeGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeGenes()[0] as EnumGene<*>;

        assertEquals(setOf(true, false), enumGene.values.toSet());

    }

    @Test
    fun testTinyIntEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status TINYINT);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (42, 77));
            """)

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeGenes().size)
        assertTrue(actions[0].seeGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeGenes()[0] as EnumGene<*>;

        assertEquals(setOf(42, 77), enumGene.values.toSet());

    }

    @Test
    fun testSmallIntEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status SMALLINT);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (42, 77));
            """)

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeGenes().size)
        assertTrue(actions[0].seeGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeGenes()[0] as EnumGene<*>;

        assertEquals(setOf(42, 77), enumGene.values.toSet());

    }

    @Test
    fun testCharEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status CHAR);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in ('A', 'B'));
            """)

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeGenes().size)
        assertTrue(actions[0].seeGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeGenes()[0] as EnumGene<*>;

        assertEquals(setOf("A", "B"), enumGene.values.toSet());

    }

    @Test
    fun testBigIntEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status BIGINT);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (42, 77));
            """)

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeGenes().size)
        assertTrue(actions[0].seeGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeGenes()[0] as EnumGene<*>;

        assertEquals(setOf(42L, 77L), enumGene.values.toSet());

    }

    @Test
    fun testDoubleEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status DOUBLE);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (1.0, 2.5));
            """)

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeGenes().size)
        assertTrue(actions[0].seeGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeGenes()[0] as EnumGene<*>;

        assertEquals(setOf(1.0, 2.5), enumGene.values.toSet());

    }

    @Test
    fun testRealEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status REAL);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (1.0, 2.5));
            """)

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeGenes().size)
        assertTrue(actions[0].seeGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeGenes()[0] as EnumGene<*>;

        assertEquals(setOf(1.0, 2.5), enumGene.values.toSet());

    }

    @Test
    fun testDecimalEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status DECIMAL);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (1.0, 2.5));
            """)

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeGenes().size)
        assertTrue(actions[0].seeGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeGenes()[0] as EnumGene<*>;

        assertEquals(setOf(1.0f, 2.5f), enumGene.values.toSet());

    }

    @Test
    fun testClobEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status CLOB);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in ('A', 'B'));
            """)

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeGenes().size)
        assertTrue(actions[0].seeGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeGenes()[0] as EnumGene<*>;

        assertEquals(setOf("A", "B"), enumGene.values.toSet());

    }

    @Test
    fun testBlobEnumGene() {

        SqlScriptRunner.execCommand(connection, """
            CREATE TABLE FOO (status BLOB);
            ALTER TABLE FOO ADD CONSTRAINT CHK_STATUS CHECK (status in (x'0000', x'FFFF'));
            """)

        val schema = SchemaExtractor.extract(connection)
        val builder = SqlInsertBuilder(schema, DirectDatabaseExecutor())

        val actions = builder.createSqlInsertionAction("FOO", setOf("status"))

        assertEquals(1, actions.size)

        assertEquals(1, actions[0].seeGenes().size)
        assertTrue(actions[0].seeGenes()[0] is EnumGene<*>)

        val enumGene = actions[0].seeGenes()[0] as EnumGene<*>;

        assertEquals(setOf("X'0000'", "X'ffff'"), enumGene.values.toSet());

    }
}