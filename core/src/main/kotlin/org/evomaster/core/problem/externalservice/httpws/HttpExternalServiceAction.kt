package org.evomaster.core.problem.externalservice.httpws

import com.github.tomakehurst.wiremock.client.MappingBuilder
import com.github.tomakehurst.wiremock.client.ResponseDefinitionBuilder
import com.github.tomakehurst.wiremock.client.WireMock.*
import com.github.tomakehurst.wiremock.common.Metadata.metadata
import com.github.tomakehurst.wiremock.matching.UrlPattern
import com.github.tomakehurst.wiremock.stubbing.StubMapping
import org.evomaster.core.problem.externalservice.ApiExternalServiceAction
import org.evomaster.core.problem.externalservice.httpws.param.HttpWsResponseParam
import org.evomaster.core.search.StructuralElement
import org.evomaster.core.search.gene.Gene
import org.evomaster.core.search.gene.string.StringGene
import org.evomaster.core.search.service.Randomness

/**
 * Action to execute the external service related need
 * to handle the external service calls.
 *
 * Typically, handle WireMock responses
 */
class HttpExternalServiceAction(
    /**
     * Received request to the respective WireMock instance
     *
     * TODO: Need to expand the properties further in future
     *  depending on the need
     */
    val request: HttpExternalServiceRequest,

    /**
     * currently, we support response with json format
     * then use ObjectGene now,
     * might extend it later
     */
    response: HttpWsResponseParam = HttpWsResponseParam(),

    /**
     * WireMock server which received the request
     */
    val externalService: HttpWsExternalService,
    active: Boolean = false,
    used: Boolean = false,
    private val id: Long
) : ApiExternalServiceAction(response, active, used) {

    companion object {
        private fun buildResponse(template: String): HttpWsResponseParam {
            // TODO: refactor later
            return HttpWsResponseParam()
        }
    }

    constructor(request: HttpExternalServiceRequest, template: String, externalService: HttpWsExternalService, id: Long) :
            this(request, buildResponse(template), externalService, id = id)

    /**
     * UUID generated by WireMock is used under ExternalServiceRequest
     * is used as ID for action.
     *
     * TODO: After the ID refactor, this needs to be changed.
     */
    override fun getName(): String {
        return request.id.toString()
    }

    override fun doInitialize(randomness: Randomness?) {
        super.doInitialize(randomness)
        if(randomness != null && randomness.nextBoolean(0.5)) {
            // higher chances to start with 200, otherwise can lose taint
            (response as HttpWsResponseParam).setStatus(200)
        }
        response.responseBody.isActive = true
        if (response.responseBody.gene is StringGene)
            (response.responseBody.gene as StringGene).forceTaintedValue()
    }

    override fun seeTopGenes(): List<out Gene> {
        return response.genes
    }


    /**
     * Each external service will have a WireMock instance representing that
     * so when the ExternalServiceAction is copied, same instance will be passed
     * into the copy too. Otherwise, we have to manage multiple instances for the
     * same external service.
     */
    override fun copyContent(): StructuralElement {
        return HttpExternalServiceAction(
            request,
            response.copy() as HttpWsResponseParam,
            externalService,
            active,
            used,
            id
        )
    }

    /**
     * This will the stub for WireMock based on the response.
     *
     * Will use the absolute URL as the key. If there is a stub exists
     * for that absolute URL will remove it before adding a new one.
     *
     * If the action is inactive ([active] is false) this will make changed to
     * the WireMock for the respective [HttpExternalServiceRequest]
     *
     * TODO: This has to moved separately to have extensive features
     *  in future.
     */
    fun buildResponse() {
        if (!active) {
            return
        }

        val existingStubs = externalService.getWireMockServer()
            .findStubMappingsByMetadata(matchingJsonPath("$.url", containing(request.absoluteURL)))

        if (existingStubs.isNotEmpty()) {
            removeStub(existingStubs)
        }

        externalService.getWireMockServer().stubFor(
            getRequestMethod(request)
                .atPriority(1)
                .willReturn(
                    buildWireMockResponse()
                )
                .withMetadata(
                    metadata()
                        .attr("url", request.absoluteURL)
                )
        )

    }

    private fun buildWireMockResponse(): ResponseDefinitionBuilder {
        val response = aResponse()
            .withStatus(viewStatus())
            .withBody(viewResponse())
        if (request.getContentType() != null){
            response.withHeader("Content-Type", request.getContentType())
        }

        return response
    }

    /**
     * Will return a [MappingBuilder] based on the HTTP method
     * TODO: Moved it to a ResponseBuilder, later
     */
    private fun getRequestMethod(request: HttpExternalServiceRequest): MappingBuilder {
        val response = when (request.method.uppercase()) {
            "GET" -> get(getUrlPattern(request.url))
            "POST" -> post(getUrlPattern(request.url))
            "PUT" -> put(getUrlPattern(request.url))
            "PATCH" -> patch(getUrlPattern(request.url))
            "DELETE" -> delete(getUrlPattern(request.url))
            "HEAD" -> head(getUrlPattern(request.url))
            "TRACE" -> trace(getUrlPattern(request.url))
            "OPTIONS" -> options(getUrlPattern(request.url))
            "ANY" -> any(getUrlPattern(request.url))
            else -> throw IllegalArgumentException("Invalid HTTP request method")
        }
        return response
    }

    /**
     * Path can be mapped to a specific URL (urlEqualTo) and Regex (urlMatching)
     * in WireMock.
     *
     * Note: urlMatching gives some issues when try to use getURL in
     * TestCaseWriter.
     *
     * TODO: Moved it to a ResponseBuilder, later
     *
     */
    private fun getUrlPattern(url: String) : UrlPattern {
        return urlEqualTo(url)
    }

    /**
     * Remove all the existing stubs from WireMock.
     * Will be used before building new response.
     */
    fun removeStub(stubs: List<StubMapping>) {
        stubs.forEach { stub ->
            externalService.getWireMockServer().removeStub(stub)
        }
    }

    private fun viewStatus(): Int {
        return (response as HttpWsResponseParam).getHttpStatusCode()
    }

    private fun viewResponse(): String {
        // TODO: Need to extend further to handle the response body based on the
        //  unmarshalled object inside SUT using the ParsedDto information.
        return (response as HttpWsResponseParam).getResponseBodyBasedOnStatus()
    }

}
