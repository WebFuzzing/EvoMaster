package org.evomaster.core.problem.security.service

import com.github.tomakehurst.wiremock.WireMockServer
import com.github.tomakehurst.wiremock.client.MappingBuilder
import com.github.tomakehurst.wiremock.client.WireMock
import com.github.tomakehurst.wiremock.common.Metadata
import com.github.tomakehurst.wiremock.core.WireMockConfiguration
import com.github.tomakehurst.wiremock.extension.responsetemplating.ResponseTemplateTransformer
import com.google.inject.Inject
import org.evomaster.core.EMConfig
import org.evomaster.core.problem.security.data.ActionStubMapping
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import javax.annotation.PostConstruct
import javax.annotation.PreDestroy

class HttpCallbackVerifier {

    @Inject
    private lateinit var config: EMConfig

    private var wireMockServer: WireMockServer? = null

    /**
     * Key holds the [Action] name and value holds the [ActionStubMapping]
     */
    private var actionStubMapping: MutableMap<String, ActionStubMapping> = mutableMapOf()

    val isActive: Boolean get() = wireMockServer != null && wireMockServer!!.isRunning

    private var counter: Long = 0

    companion object {
        private val log: Logger = LoggerFactory.getLogger(HttpCallbackVerifier::class.java)

        const val DEFAULT_RESPONSE_CODE = 418
        const val DEFAULT_RESPONSE_BODY = "I'm a teapot"
        const val DEFAULT_RESPONSE_PRIORITY = 100

        const val SSRF_RESPONSE_STATUS_CODE = 200
        const val SSRF_RESPONSE_BODY = "SSRF"
    }

    @PostConstruct
    fun init() {
        if (config.ssrf) {
            log.debug("Initializing {}", HttpCallbackVerifier::class.simpleName)
        }
    }

    @PreDestroy
    fun destroy() {
        if (config.ssrf) {
            stop()
        }
    }

    fun prepare() {
        if (isActive) {
            log.debug("{} is already active.", HttpCallbackVerifier::class.simpleName)
            return
        }

        try {
            val config = WireMockConfiguration()
                .extensions(ResponseTemplateTransformer(false))
                .dynamicPort()

            val wm = WireMockServer(config)
            wm.start()
            wm.stubFor(getDefaultStub())

            wireMockServer = wm
        } catch (e: Exception) {
            throw RuntimeException(
                e.message +
                        ". If it is macOS, please make sure loopback alias is set."
            )
        }
    }

    fun isCallbackURL(value: String): Boolean {
        if (!isActive) {
            return false
        }
        // Regex pattern looks for URL contains the pattern generated by the [HTTPCallbackVerifier].
        // TODO: Change the port to Regex
        val pattern =
            """^http:\/\/localhost:${wireMockServer!!.port()}\/EM_SSRF_\d+$""".toRegex()

        return pattern.matches(value)
    }

    /**
     * Method generates a unique callback link to be used as payload for SSRF.
     */
    fun generateCallbackLink(name: String): String {
        // FIXME: sink/EM_0 <- slash get replaced with a comma at some point, which fails
        //  the verification based on the metadata

        if (actionStubMapping.containsKey(name)) {
            if (actionStubMapping[name] != null) {
                return actionStubMapping[name]!!.url
            }
        }

        val stub = "/EM_SSRF_${counter}"

        wireMockServer!!.stubFor(
            WireMock.any(WireMock.urlEqualTo(stub))
                .withMetadata(Metadata.metadata().attr("ssrf", name))
                .atPriority(1)
                .willReturn(
                    WireMock.aResponse()
                        .withStatus(SSRF_RESPONSE_STATUS_CODE)
                        .withBody(SSRF_RESPONSE_BODY)
                )
        )

        val link = "http://localhost:${wireMockServer!!.port()}$stub"

        actionStubMapping[name] = ActionStubMapping(
            counter,
            name,
            stub,
            wireMockServer!!.port(),
            link
        )
        counter++

        return link
    }

    /**
     * Get all the [ActionStubMapping] as [List].
     */
    fun getActionVerifierMappings(): List<ActionStubMapping> {
        return actionStubMapping.values.toList()
    }

    /**
     * Return the [ActionStubMapping] for the [Action] name.
     */
    fun getActionVerifierMapping(name: String): ActionStubMapping? {
        if (actionStubMapping.containsKey(name)) {
            return actionStubMapping[name]
        }
        return null
    }

    /**
     * @param name represents the Action name
     * During stub creation, stubs are tagged with Action name in the metadata.
     */
    fun verify(name: String): Boolean {
        if (isActive) {
            wireMockServer!!
                .allServeEvents
                .filter { event -> event.wasMatched }
                .forEach { e ->
                    val matched = e.stubMapping.metadata
                    if (matched != null && matched.getString("ssrf") == name) {
                        return true
                    }
                }
        }

        return false
    }

    fun reset() {
        counter = 0
        actionStubMapping.clear()
        if (isActive) {
            wireMockServer?.resetAll()
            wireMockServer?.stubFor(getDefaultStub())
        }
    }

    fun stop() {
        reset()
        if (isActive) {
            wireMockServer?.stop()
            wireMockServer = null
        }
    }

    private fun getDefaultStub(): MappingBuilder {
        return WireMock.any(WireMock.anyUrl())
            .atPriority(DEFAULT_RESPONSE_PRIORITY)
            .willReturn(
                WireMock.aResponse()
                    .withStatus(DEFAULT_RESPONSE_CODE)
                    .withBody(DEFAULT_RESPONSE_BODY)
            )
    }
}
