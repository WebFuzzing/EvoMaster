package org.evomaster.core.database

import org.evomaster.client.java.controller.api.dto.database.operations.DatabaseCommandDto
import org.evomaster.client.java.controller.api.dto.database.operations.InsertionDto
import org.evomaster.client.java.controller.api.dto.database.operations.InsertionEntryDto
import org.evomaster.core.search.gene.Gene
import org.evomaster.core.search.gene.SqlForeignKeyGene
import org.evomaster.core.search.gene.SqlPrimaryKeyGene


object DbActionTransformer {

    fun transform(insertions: List<DbAction>, sqlIdMap : Map<Long, Long> = mapOf()) : DatabaseCommandDto {

        val list = mutableListOf<InsertionDto>()
        val previous = mutableListOf<Gene>()

        for (i in 0 until insertions.size) {

            val action = insertions[i]
            if(action.representExistingData){
                /*
                    Even if not going to be part of the DTO, should still be able
                    to point to it with FKs
                 */
                previous.addAll(action.seeGenes())
                continue
            }


            val insertion = InsertionDto().apply { targetTable = action.table.name }

            for (g in action.seeGenes()) {
                if (g is SqlPrimaryKeyGene) {
                    /*
                        If there is more than one primary key field, this
                        will be overridden.
                        But, as we need it only for automatically generated ones,
                        this shouldn't matter, as in that case there should be just 1.
                     */
                    insertion.id = g.uniqueId
                }

                if (!g.isPrintable()) {
                    continue
                }

                val entry = InsertionEntryDto()

                var isFkReferenceToNonPrintable = false

                if (g is SqlForeignKeyGene) {
                    isFkReferenceToNonPrintable = handleSqlForeignKey(g, previous, entry, sqlIdMap)
                } else if (g is SqlPrimaryKeyGene) {
                    val k = g.gene
                    if (k is SqlForeignKeyGene) {
                        isFkReferenceToNonPrintable = handleSqlForeignKey(k, previous, entry, sqlIdMap)
                    } else {
                        entry.printableValue = g.getValueAsPrintableString(targetFormat = null)
                    }
                } else {
                    entry.printableValue = g.getValueAsPrintableString(targetFormat = null)
                }

                entry.variableName = g.getVariableName()
                /*  TODO: the above code needs to be refactored to get the targetFormat from EMConfig.
                    The target format has an impact on which characters are escaped and may result in compilation errors.
                    The current version performs no escaping of characters by default (i.e. when the target format is null).
                */
                /*
                    At the current moment, we do allow the "printing" of auto-increment
                    values that are already existing in the database, as those
                    are marked as immutable.
                    In those cases, we do not need to keep track of those values
                 */
                entry.keepAutoGeneratedValue = action.selectedColumns
                        .first { it.name==g.name }
                        .foreignKeyToAutoIncrement
                        &&
                        isFkReferenceToNonPrintable

                insertion.data.add(entry)
            }

            list.add(insertion)
            previous.addAll(action.seeGenes())
        }

        val dto = DatabaseCommandDto().apply { this.insertions = list }

        return dto
    }

    private fun handleSqlForeignKey(
            g: SqlForeignKeyGene,
            previous: List<Gene>,
            entry: InsertionEntryDto,
            sqlIdMap: Map<Long, Long>
    ) : Boolean {

        var justCreated = false
        val isFkReferenceToNonPrintable = try{
            g.isReferenceToNonPrintable(previous)
        }catch(e : Exception){
            if (sqlIdMap.containsKey(g.uniqueIdOfPrimaryKey)){
                justCreated = true
                false
            }
            else throw IllegalArgumentException(e)
        }

        if (isFkReferenceToNonPrintable) {
            entry.foreignKeyToPreviouslyGeneratedRow = g.uniqueIdOfPrimaryKey
        } else {
            entry.printableValue = if(justCreated) sqlIdMap.getValue(g.uniqueIdOfPrimaryKey).toString() else g.getValueAsPrintableString(previous, targetFormat = null)
        }

        return isFkReferenceToNonPrintable
    }
}